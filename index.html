<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>원자력 발전소 엔지니어링 마스터 · 4라운드 · (GWh)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root{ --bg:#0b1020;--panel:#121830;--muted:#1a2140;--ink:#e7ecff;--ink-2:#b5c0ff;--ink-3:#8fa1ff;--accent:#6ea8ff;--accent-2:#9ad0ff;--good:#39d98a;--warn:#ffd166;--bad:#ff6b6b;--card:#10172a;--radius:16px;--shadow:0 10px 30px rgba(0,0,0,.35);} 
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#070b18 0%, #0b1020 60%, #0b1020 100%);color:var(--ink);font:15px/1.45 Pretendard, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, Arial}
    a{color:var(--accent)}
    header{position:sticky;top:0;z-index:50;background:rgba(7,11,24,.7);backdrop-filter:blur(8px);border-bottom:1px solid rgba(255,255,255,.05)}
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    .brand{display:flex;gap:12px;align-items:center}
    .logo{width:36px;height:36px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent-2));box-shadow:0 6px 18px rgba(110,168,255,.35)}
    h1{font-size:18px;margin:0}

    main{max-width:1200px;margin:0 auto;padding:24px;display:grid;grid-template-columns:360px 1fr;gap:20px}
    @media (max-width: 980px){main{grid-template-columns:1fr}}

    .panel{background:var(--panel);border:1px solid rgba(255,255,255,.06);border-radius:var(--radius);box-shadow:var(--shadow)}
    .panel h2{font-size:16px;margin:0 0 12px 0;color:var(--ink-2)}
    .section{padding:16px 16px 14px;border-top:1px solid rgba(255,255,255,.06)}
    .section:first-child{border-top:none}

    label{display:block;margin:6px 0 6px 2px;color:var(--ink-2)}
    input, select, button, textarea{font:inherit}
    input[type="number"], input[type="text"], select{width:100%;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.07);background:var(--card);color:var(--ink)}

    button{padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.08);background:linear-gradient(180deg,#182043,#121a35);color:var(--ink);cursor:pointer}
    button.primary{background:linear-gradient(180deg,#2a5cff,#234de0);border-color:rgba(110,168,255,.35)}
    button.ghost{background:#0f142a}
    button:disabled{opacity:.55;cursor:not-allowed}

    .meter{height:12px;background:linear-gradient(180deg,#0e1430,#0b1126);border-radius:999px;border:1px solid rgba(255,255,255,.08);position:relative;overflow:hidden}
    .meter > i{position:absolute;inset:0;transform-origin:left center;transform:scaleX(0);background:linear-gradient(90deg,#9ad0ff,#6ea8ff);box-shadow:inset 0 0 12px rgba(154,208,255,.7)}
    .meter.bad > i{background:linear-gradient(90deg,#ffb3b3,#ff6b6b)}
    .meter.ok > i{background:linear-gradient(90deg,#ffe08a,#ffd166)}
    .meter.good > i{background:linear-gradient(90deg,#78f0bb,#39d98a)}

    .badge{display:inline-block;padding:6px 10px;border-radius:999px;background:#0f1530;border:1px solid rgba(255,255,255,.08);font-size:12px;color:var(--ink-2)}
    .muted{color:var(--ink-2)}

    table{width:100%;border-collapse:collapse}
    th,td{padding:10px;border-bottom:1px solid rgba(255,255,255,.06);text-align:right}
    th:first-child,td:first-child{text-align:left}

    .tabs{display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap}
    .tabs button{flex:0 0 auto;padding:8px 10px;border-radius:10px;background:#0e1430;border:1px solid rgba(255,255,255,.08);color:var(--ink-2)}
    .tabs button.hl{outline:2px solid var(--accent);box-shadow:0 0 0 3px rgba(110,168,255,.25)}
    .tabs button.active{background:#ffffff;color:#0e1430;border-color:#ffffff}

    .bigStats{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:14px}
    .stat{background:#0e1430;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:14px 16px}
    .stat .k{font-size:14px;color:var(--ink-2);margin-bottom:4px}
    .stat .v{font-size:28px;font-weight:800;letter-spacing:.2px}

    #predRange{font-size:26px;font-weight:800;text-align:center;padding:18px 16px}

    .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:#0e1430;border:1px solid rgba(255,255,255,.07);font-size:12px;color:var(--ink-2)}

    .small{font-size:12px}

    /* Toast / Modal */
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:200}
    .toast{background:#121830;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:18px 20px;min-width:260px;text-align:center;box-shadow:var(--shadow);animation:pop .18s ease-out}
    .toast h3{margin:0 0 4px 0;font-size:18px}
    .toast p{margin:0;font-size:14px;color:var(--ink-2)}
    #roundToast .toast{min-width:520px;padding:34px 38px}
    #roundToast .toast h3{font-size:28px}
    #roundToast .toast p{font-size:20px}
    @keyframes pop{from{transform:translateY(4px) scale(.98);opacity:.0}to{transform:translateY(0) scale(1);opacity:1}}
    .cta{font-size:18px;padding:16px 20px;width:100%}
    #codeInput{font-size:16px;padding:14px 14px}
    #btnAddCode{font-size:16px;padding:12px 16px}
  </style>
</head>
<body>
  <header>
    <div class="wrap brand">
      <div class="logo" aria-hidden></div>
      <h1>원자력 발전소 엔지니어링 마스터 · 4라운드</h1>
      <div style="margin-left:auto" class="muted"><strong>단위: GWh/월</strong> · 2010 시드 → 2025 예측</div>
    </div>
  </header>

  <main>
    <!-- Left: Controls -->
    <aside class="panel" aria-label="설정 및 데이터 입력">
      <div class="section">
        <h2>게임 세팅</h2>
        <button class="primary" id="btnNewGame">새로운 게임 시작하기</button>
        <div class="small muted" style="margin-top:8px">시작 후에는 시나리오 변경이 불가합니다. 새 게임으로 재시작하세요.</div>
      </div>

      <div class="section">
        <h2>연구데이터 입력</h2>
        <label for="codeInput">연구카드 코드</label>
        <div style="display:flex; gap:8px; align-items:center">
          <input id="codeInput" type="text" placeholder="코드를 입력하세요" maxlength="8" style="flex:1" />
          <button id="btnAddCode">추가</button>
        </div>
        <div class="small muted" style="margin-top:6px">코드만 입력하면 해당 카드 데이터가 학습에 반영됩니다.</div>
        <div id="appliedList" class="small" style="margin-top:8px"></div>
      </div>

      <div class="section">
        <h2>AI 예측 적중률</h2>
        <div class="meter" id="accMeter" aria-label="학습 수준"><i></i></div>
        <div style="display:flex;justify-content:space-between;margin-top:6px">
          <div id="accLabel" class="badge">—</div>
          <div class="muted small" id="accExplain">유효 표본 0/12 · 최근연도 0/5 · 기온 0/6</div>
        </div>
        <div class="small muted" style="margin-top:8px">결과 공개 전, 입력된 카드만으로 산출합니다.</div>
      </div>

      
    </aside>

    <!-- Right: Runtime -->
    <section class="panel" aria-label="라운드 진행">
      <div class="section">
        <h2>라운드 진행</h2>
        <div class="bigStats" role="group" aria-label="현재 상태">
          <div class="stat"><div class="k">현재 라운드</div><div class="v" id="roundNow">—</div></div>
          <div class="stat"><div class="k">현재 월</div><div class="v" id="monthNow">—</div></div>
        </div>
      </div>

      <div class="section">
        <h2>예측</h2>
        <div>
          <label>예상 도시 전력 수요량 (GWh)</label>
          <input id="predRange" type="text" readonly value="—" placeholder="최저 ~ 최고">
        </div>
        <div class="small muted" style="margin-top:6px">시즌 기초값(2010) + 연도 성장(α) + 기온 민감도(β)</div>
        <div style="margin-top:10px">
          <button id="btnPredict" class="primary cta" disabled>도시 전력 수요 예측</button>
          <button id="btnNext" class="ghost cta" disabled>다음 달로 넘어가기</button>
        </div>
      </div>

      <div class="section">
        <h2>연구 데이터 차트</h2>
        <div class="tabs" id="yearTabs"></div>
        <canvas id="dataChart" height="230" aria-label="연구데이터 차트"></canvas>
        <div id="yearSummary" class="small" style="margin-top:8px"></div>
        <table id="yearTable" style="margin-top:8px">
          <thead><tr><th>월</th><th>전력수요(GWh)</th><th>월별기온(°C)</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="section">
        <h2>라운드 로그</h2>
        <table id="logTable" aria-describedby="라운드별 기록">
          <thead>
            <tr>
              <th>라운드</th>
              <th>월</th>
              <th>사전 적중률</th>
              <th>예상 범위(GWh)</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div style="margin-top:8px"><button id="btnExport" class="ghost">로그 CSV 내보내기</button></div>
      </div>
    </section>
  </main>

  <!-- Toast: round/month -->
  <div id="roundToast" class="overlay" aria-hidden="true">
    <div class="toast">
      <h3 id="toastTitle">라운드 진행</h3>
      <p id="toastText">라운드 — / —월</p>
    </div>
  </div>

  <!-- Modal: code error -->
  <div id="codeErrorModal" class="overlay">
    <div class="toast" style="min-width:320px">
      <h3 style="margin:0 0 8px 0">코드 입력 오류</h3>
      <div id="codeErrorText" class="small"></div>
      <div style="margin-top:12px;display:flex;justify-content:flex-end;gap:8px">
        <button id="btnCodeErrorClose" class="primary">다시 입력하기</button>
      </div>
    </div>
  </div>

  <!-- Modal: scenario selection (시작 전 전용) -->
  <div id="modal" class="overlay">
    <div class="toast" style="min-width:340px">
      <h2 style="margin-top:0">새 게임 시작</h2>
      <label style="margin-top:10px">시작 월</label>
      <select id="startMonth"></select>
      <div style="margin-top:16px;display:flex;gap:8px;justify-content:flex-end">
        <button id="btnCancelScenario" class="ghost">취소</button>
        <button class="primary" id="btnConfirmScenario">확인</button>
      </div>
    </div>
  </div>

  <!-- Modal: confirm reset during game -->
  <div id="confirmReset" class="overlay">
    <div class="toast" style="min-width:360px">
      <h3 style="margin:0 0 8px 0">진행상황이 초기화됩니다.</h3>
      <div class="small muted">확인을 누르면 초기 시나리오 선택 화면으로 돌아갑니다.</div>
      <div style="margin-top:12px;display:flex;justify-content:flex-end;gap:8px">
        <button id="btnResetNo" class="ghost">취소</button>
        <button id="btnResetYes" class="primary">확인</button>
      </div>
    </div>
  </div>

  <script>
    // ================== Constants ==================
    const MONTHS = ["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"];
    const BETA = [0.002,0.002,0.005,0.006,0.010,0.015,0.020,0.020,0.012,0.006,0.003,0.002];

    // 월별 기온 합성용 베이스(2011) 및 2010 기준 벡터
    const TBASE2011 = [1.7,3.7,7.2,12.2,17.2,21.2,23.2,22.7,18.2,13.2,7.7,3.2];
    const TBASE2010 = TBASE2011.map(v=>+(v-0.2).toFixed(1)); // 2010은 2011보다 약간 낮게
    const WARM_RATE = 0.03; // 연 0.03°C 상승
    function synthMonthlyTemps(y){ const delta=(y-2010)*WARM_RATE; return TBASE2010.map(v=>+(v+delta).toFixed(1)); }
    function getMonthlyTemp(y,m){ const t=state.tempCards.find(t=>t.y===y); if(t&&t.temps&&t.temps.length===12){ return t.temps[m-1]; } const est=synthMonthlyTemps(y); return est[m-1]; }

    // 모든 수치 단위: GWh/월

    // 2025 정답(단위: GWh)
    const TRUE_2025 = {
      A: { demand: [10.0,9.5,9.0,9.0,10.5,12.0,14.0,15.0,12.5,11.0,10.0,11.0] }
    };
    // 2010 기초(단위: GWh) = 2025의 80%
    const BASE_2010 = {
      A: TRUE_2025.A.demand.map(v => +(v*0.8).toFixed(1))
    };

    // ================== Embedded DB (A 전용) ==================
    const CARD_DB = {}; // 기본은 비어두고, 아래 GA6 카드로 채웁니다.

    // ---- A-only: GA6 카드(6개월) 무작위 월 구성
    const GA6_PLAN_A = [
      {code:'Q7M', year:2010, months:[1,3,4,7,10,12]},
      {code:'L3Z', year:2010, months:[2,5,6,8,9,11]},
      {code:'H9X', year:2012, months:[1,2,4,6,9,12]},
      {code:'T2V', year:2012, months:[3,5,7,8,10,11]},
      {code:'R5K', year:2014, months:[1,5,6,7,9,12]},
      {code:'M8J', year:2014, months:[2,3,4,8,10,11]},
      {code:'C4P', year:2017, months:[1,4,6,8,9,11]},
      {code:'N1D', year:2017, months:[2,3,5,7,10,12]},
      {code:'V6S', year:2019, months:[1,3,5,6,8,12]},
      {code:'Y0A', year:2019, months:[2,4,7,9,10,11]},
      {code:'B2Q', year:2022, months:[1,2,6,7,9,11]},
      {code:'W9F', year:2024, months:[3,4,5,8,10,12]},
    ];
    const ALPHA_TRUE = 0.0166666667; // per year so that 2010→2025 grows ~25%

    // Monthly temperature generator (base on 2011 profile + gentle warming)
    const BASE_TEMPS_2011 = [1.7,3.7,7.2,12.2,17.2,21.2,23.2,22.7,18.2,13.2,7.7,3.2];
    const WARMING_PER_YEAR = 0.04; // °C/year (plausible small trend)
    function monthlyTempsForYear(y){
      const dy = y - 2011;
      return BASE_TEMPS_2011.map(v => +(v + dy*WARMING_PER_YEAR).toFixed(1));
    }
    function buildGA6Items(year, months){
      const g = 1 + ALPHA_TRUE*(year-2010);
      const temps = monthlyTempsForYear(year);
      return months.map(m => ({ m, val: +(BASE_2010.A[m-1]*g).toFixed(1), temp: temps[m-1] }));
    }
    function injectGA6(){
      GA6_PLAN_A.forEach(p => {
        CARD_DB[p.code] = { type:'GA6', scenario:'A', year:p.year, items: buildGA6Items(p.year, p.months) };
      });
    }

    // ================== State ==================
    const state = {
      started:false,
      scenario:null,
      startMonth:1,
      round:0,
      maxRounds:4,
      monthNow:1,
      demandCards:[], // {y,m,val} in GWh
      tempCards:[],   // {y, temps:[12]}
      appliedCodes:[],
      cardDB:{},
    };

    // ================== Utils ==================
    function $(id){return document.getElementById(id)}
    function clamp(x,min,max){return Math.max(min, Math.min(max,x))}
    function monthDiff(a,b){ const d = Math.abs(a-b); return Math.min(d, 12-d); }
    function wMonth(m, mNow){ const d = monthDiff(m,mNow); if(d===0) return 1.0; if(d===1) return 0.7; if(d===2) return 0.4; return 0.2; }
    function wRecency(y){ if(y>=2019) return 1.0; if(y>=2015) return 0.7; return 0.4 }
    function fmt(n){ return (n===null||n===undefined||Number.isNaN(n))? '—' : (+n.toFixed(2)).toString() }

    // ================== Seed: 2011 sample (auto-insert, not a card) ==================
    function seed2011(){
      const s = state.scenario; if(!s) return;
      // ---- Demand: fill ALL 12 months for 2011 based on 2010 base × 1.02
      for(let m=1;m<=12;m++){
        const base = BASE_2010[s][m-1];
        const val = +(base*1.02).toFixed(1); // ~+2% vs 2010 across all months
        const idx = state.demandCards.findIndex(d=>d.y===2011 && d.m===m);
        if(idx>=0) state.demandCards[idx] = {y:2011,m,val}; else state.demandCards.push({y:2011,m,val});
      }
      // ---- Temperature: full 12 months present for 2011
      const temps2011=[1.7,3.7,7.2,12.2,17.2,21.2,23.2,22.7,18.2,13.2,7.7,3.2];
      const ti = state.tempCards.findIndex(t=>t.y===2011);
      if(ti>=0) state.tempCards[ti] = {y:2011, temps: temps2011}; else state.tempCards.push({y:2011, temps: temps2011});
      state._seed2011 = true;
    }

    // ================== Pre-Result Accuracy ==================
    function computePreAcc(){
      if(!state.started) return {score:0,label:'—',M:0,Div:0,Temp:0,TempSlots:0};
      const mNow = state.monthNow; let eff=0; const recentYears = new Set();
      for(const c of state.demandCards){ eff += wMonth(c.m, mNow) * wRecency(c.y); if(c.y>=2019) recentYears.add(c.y); }
      const M = Math.min(eff/12, 1);
      const Diversity = Math.min(recentYears.size/5, 1);
      // Temperature coverage: month-aware weighted coverage across known months
      let tEff=0; for(const t of state.tempCards){ for(let m=1;m<=12;m++){ const v=t.temps && t.temps[m-1]; if(v!=null){ tEff += wMonth(m,mNow) * wRecency(t.y); } } }
      const TempEffect = Math.min(tEff/12, 1);
      const TempSlots = Math.round(Math.min(tEff,12));
      // Keep initial accuracy realistic with 2011 seed only (~20–35%)
      const Seed = state._seed2011 ? 0.10 : 0; 
      let s = 100*(Seed + 0.50*M + 0.22*Diversity + 0.13*TempEffect);
      s = Math.round(clamp(s,20,95));
      const label = s<40? '초보' : s<60? '보통' : s<80? '견고' : s<91? '정확' : '마스터';
      return {score:s,label,M,Div:Diversity,Temp:TempEffect,TempSlots};
    }
    function renderAcc(){
      const {score,label,M,Div,Temp,TempSlots} = computePreAcc();
      const meter = $("accMeter"); const bar = meter.querySelector('i');
      bar.style.transform = `scaleX(${score/100})`;
      meter.classList.remove('bad','ok','good');
      if(score<50) meter.classList.add('bad'); else if(score<70) meter.classList.add('ok'); else meter.classList.add('good');
      $("accLabel").textContent = `${score}% · ${label}`;
      $("accExplain").textContent = `유효 표본 ${Math.round(M*12)}/12 · 최근연도 ${Math.round(Div*5)}/5 · 기온 ${TempSlots}/12`;
    }

    // ================== Prediction (weighted OLS regression) ==================
    const RIDGE = 1e-6;

    function getAvgTempByYear(y){
      const t = state.tempCards.find(t=>t.y===y);
      if(t && t.temps && t.temps.length===12){
        return t.temps.reduce((a,b)=>a+b,0)/12;
      }
      // 없으면 합성 monthly로 계산
      const est = synthMonthlyTemps(y); return est.reduce((a,b)=>a+b,0)/12;
    }

    function weightedOLS(X, y, w){
      const p = X[0].length; const XtWX = Array.from({length:p},()=>Array(p).fill(0));
      const XtWy = Array(p).fill(0); let nEff=0;
      for(let i=0;i<X.length;i++){
        const wi = w[i]; nEff += wi;
        for(let a=0;a<p;a++){
          XtWy[a] += X[i][a]*y[i]*wi;
          for(let b=0;b<p;b++) XtWX[a][b] += X[i][a]*X[i][b]*wi;
        }
      }
      for(let d=0; d<p; d++){ XtWX[d][d] += RIDGE; }
      const A = XtWX.map((row,i)=>row.concat([XtWy[i]]));
      for(let col=0; col<p; col++){
        let piv=col; for(let r=col+1;r<p;r++) if(Math.abs(A[r][col])>Math.abs(A[piv][col])) piv=r;
        if(Math.abs(A[piv][col])<1e-10) return null;
        if(piv!==col){ const tmp=A[col]; A[col]=A[piv]; A[piv]=tmp; }
        const div=A[col][col]; for(let c=col;c<=p;c++) A[col][c]/=div;
        for(let r=0;r<p;r++) if(r!==col){ const factor=A[r][col]; for(let c=col;c<=p;c++) A[r][c]-=factor*A[col][c]; }
      }
      const beta = A.map(row=>row[p]);
      let rss=0, wsum=0; for(let i=0;i<X.length;i++){ let yhat=0; for(let j=0;j<p;j++) yhat+=beta[j]*X[i][j]; const e=y[i]-yhat; rss += w[i]*e*e; wsum+=w[i]; }
      const dof = Math.max(1, X.length - p);
      const residSD = Math.sqrt(rss/Math.max(1e-9, dof));
      return {beta, residSD, nEff};
    }

    function buildRegressionModel(){
      if(!state.scenario) return null;
      const X=[], y=[], w=[];
      for(const s of state.demandCards){
        const base = BASE_2010[state.scenario]?.[s.m-1]; if(base==null) continue;
        const t = s.y - 2010;
        const tempM = getMonthlyTemp(s.y, s.m);
        const feat = [1, base, t, tempM];
        X.push(feat); y.push(s.val); w.push(wMonth(s.m, state.monthNow)*wRecency(s.y));
      }
      if(X.length<2) return null;
      return weightedOLS(X,y,w);
    }

    // ---- Uncertainty driven by pre-score (accuracy) ----
    function widthFromAccuracy(score){
      // 20% → ~3.0 GWh, 50% → ~2.0, 70% → ~1.3, 85% → ~0.9, 95% → ~0.7
      return clamp(3.4 - 0.03*score, 0.6, 3.2);
    }
    function computeUncertainty(model){
      if(!state.started) return 3.0;
      const pre = computePreAcc();
      let w = widthFromAccuracy(pre.score);
      if(model && Number.isFinite(model.residSD)){
        w = Math.max(model.residSD*1.6, w*0.9);
      }
      w *= (1 - 0.06*(state.round-1));
      if(state.round>=4) w = Math.min(w, 0.9);
      return clamp(w, 0.6, 3.2);
    }

    function predictCurrent(){
      if(!state.started) return null;
      const mIdx = state.monthNow-1;
      const base = BASE_2010[state.scenario][mIdx];
      const model = buildRegressionModel();
      if(model && model.beta){
        const temp2025 = getAvgTempByYear(2025) ?? 15.0;
        const x = [1, base, (2025-2010), temp2025];
        let yhat = model.beta[0]*x[0] + model.beta[1]*x[1] + model.beta[2]*x[2] + model.beta[3]*x[3];
        if(!Number.isFinite(yhat)) yhat = base;
        yhat = Math.max(0.5*base, yhat);
        const w = computeUncertainty(model);
        return {yhat, min:yhat-w, max:yhat+w, width:w};
      }
      const ALPHA_CAP = 0.02;
      let num=0,den=0; for(const c of state.demandCards){ const t=c.y-2010; if(t<=0) continue; const b=BASE_2010[state.scenario]?.[c.m-1]; if(!b) continue; const r=c.val/b; const est=(r-1)/t; const wt=wMonth(c.m,state.monthNow)*wRecency(c.y); num+=est*wt; den+=wt; }
      const a = clamp(den>0? num/den : 0, 0, ALPHA_CAP);
      const growth=1+a*(2025-2010);
      let yhat = base*growth; const w = computeUncertainty(null);
      return {yhat, min:yhat-w, max:yhat+w, width:w};
    }

    // ================== Chart (bar: monthly demand, line: monthly temp) ==================
    let chart; let currentChartYear = 2011; const roundHighlights = new Set();
    function addHighlight(year){ const el=document.getElementById(`tab-year-${year}`); if(el){ el.classList.add('hl'); roundHighlights.add(year);} }
    function clearHighlights(){ for(const y of roundHighlights){ const el=document.getElementById(`tab-year-${y}`); if(el){ el.classList.remove('hl'); } } roundHighlights.clear(); }
    function updateChart(year){
      document.querySelectorAll('#yearTabs button').forEach(b=>{ b.classList.remove('active'); });
      const act=document.getElementById(`tab-year-${year}`); if(act) act.classList.add('active');
      if(!state.scenario){ return; }
      currentChartYear = year;
      const ctx = $("dataChart").getContext('2d');

      let demand = Array.from({length:12}, (_,i)=>{
        const d=state.demandCards.find(c=>c.y===year && c.m===i+1);
        return d? d.val : null;
      });

      const tEntry = state.tempCards.find(t=>t.y===year);
      const tempLine = tEntry? tEntry.temps : Array(12).fill(null);

      const datasets = [{ label: '전력수요(GWh)', data: demand, yAxisID:'y', type:'bar', backgroundColor: '#6ea8ff', borderRadius: 6 }];
      if(year===2010){ datasets.push({ label:'기초(2010) GWh', data: BASE_2010[state.scenario], yAxisID:'y', type:'line', borderColor:'#9ad0ff', borderWidth:2, borderDash:[6,4], pointRadius:0 }); }
      datasets.push({ label: '월별기온(°C)', data: tempLine, yAxisID:'y1', type:'line', borderColor:'#ffd166', borderWidth:2, spanGaps:true, pointRadius:2 });

      if(chart) chart.destroy();
      chart = new Chart(ctx, {
        type: 'bar',
        data: { labels: MONTHS, datasets },
        options: {
          responsive:true,
          plugins:{ legend:{ labels:{ color:'#cfe0ff' } }, tooltip:{ callbacks:{ label: (ctx)=>{ const v=ctx.raw; return ctx.dataset.label+': '+(v===null?'?':v); } } } },
          scales:{ x:{ ticks:{ color:'#b5c0ff' }, grid:{ color:'rgba(255,255,255,.06)'} }, y:{ beginAtZero:true, position:'left', ticks:{ color:'#b5c0ff' }, grid:{ color:'rgba(255,255,255,.06)'} }, y1:{ beginAtZero:false, position:'right', ticks:{ color:'#ffd166' }, grid:{ drawOnChartArea:false } } }
        }
      });

      $("yearSummary").textContent = `연도 ${year} · 월별기온: ${tEntry? '입력됨' : '?'}`;
      const tb = $("yearTable").querySelector('tbody'); tb.innerHTML='';
      for(let i=0;i<12;i++){
        const tr=document.createElement('tr');
        const val = demand[i];
        const t = tEntry? (tEntry.temps[i]!==null? (+tEntry.temps[i]).toFixed(1):'?') : '?';
        tr.innerHTML = `<td style="text-align:left">${MONTHS[i]}</td><td>${val===null?'?':val}</td><td>${t}</td>`;
        tb.appendChild(tr);
      }
    }

    function buildYearTabs(){ const tabs=$("yearTabs"); tabs.innerHTML=''; for(let y=2010;y<=2024;y++){ const b=document.createElement('button'); b.id=`tab-year-${y}`; b.textContent=y; b.addEventListener('click',()=>updateChart(y)); tabs.appendChild(b);} }

    // ================== Lists & Modal helpers ==================
    function renderAppliedList(){
      const el=$("appliedList");
      if(!state.appliedCodes.length){ el.textContent='적용된 코드 없음'; return; }
      el.innerHTML = state.appliedCodes.map(c=>`<span class="badge" data-code="${c}" style="cursor:pointer">${c}</span>`).join(' ');
      el.querySelectorAll('span.badge').forEach(chip=>{
        chip.addEventListener('click', ()=>{
          const r = state.cardDB[chip.dataset.code];
          if(!r) return;
          let y = r.year;
          if(!y && r.items && r.items.length){ y = r.items[0].y; }
          if(y){ updateChart(y); addHighlight(y); }
        });
      });
    }
    function showCodeError(msg){ const m=$("codeErrorModal"); $("codeErrorText").textContent=msg; m.style.display='flex'; }
    function closeCodeError(){ const m=$("codeErrorModal"); m.style.display='none'; $("codeInput").focus(); }

    // Round toast
    function showRoundToast(){ const ov=$("roundToast"); $("toastTitle").textContent='라운드 진행'; $("toastText").textContent=`라운드 ${state.round} / ${MONTHS[state.monthNow-1]}`; ov.style.display='flex'; setTimeout(()=>{ ov.style.display='none'; }, 3000); }

    // ================== Code Apply ==================
    function applyCode(){
      const raw = $("codeInput").value.trim();
      const code = raw.toUpperCase();
      if(!code){ showCodeError('코드를 입력하세요'); return; }
      const card = state.cardDB[code] || null;
      if(!card){ showCodeError('해당 코드를 찾을 수 없습니다.'); return; }
      if(state.appliedCodes.includes(code)){ showCodeError('이미 적용된 코드입니다.'); return; }
      if((card.type==='GA2' || card.type==='GA3' || card.type==='GA6') && !state.scenario){ showCodeError('새 게임 시작 후 사용하세요.'); return; }
      if((card.scenario||state.scenario) && state.scenario && card.scenario && card.scenario!==state.scenario){ showCodeError(`현재 시나리오(${state.scenario})와 다른 카드입니다.`); return; }

      const affectedYears = new Set();
      if(card.type==='GA2' || card.type==='GA3' || card.type==='GA6'){
        const y = card.year; affectedYears.add(y);
        // ensure temp container exists for that year
        let tIdx = state.tempCards.findIndex(t=>t.y===y);
        if(tIdx<0){ state.tempCards.push({y, temps:Array(12).fill(null)}); tIdx = state.tempCards.length-1; }
        for(const item of card.items){
          const {m,val,temp} = item;
          // demand merge
          const idx = state.demandCards.findIndex(d=>d.y===y && d.m===m);
          if(idx>=0) state.demandCards[idx] = {y,m,val}; else state.demandCards.push({y,m,val});
          // temperature merge (month-level)
          state.tempCards[tIdx].temps[m-1] = temp;
        }
      } else if(card.type==='NA2'){
        for(const t of card.items){
          affectedYears.add(t.y);
          const idx = state.tempCards.findIndex(x=>x.y===t.y);
          if(idx>=0) state.tempCards[idx] = {y:t.y, temps:[...t.temps]};
          else state.tempCards.push({y:t.y, temps:[...t.temps]});
        }
      }

      state.appliedCodes.push(code);
      $("codeInput").value='';
      renderAppliedList(); renderAcc();
      const years=[...affectedYears];
      if(years.length){
        const prefer = years.includes(currentChartYear) ? currentChartYear : years.sort((a,b)=>a-b)[years.length-1];
        updateChart(prefer);
        addHighlight(prefer);
      }
    }

    // ================== Log & Export ==================
    function appendLog(pred){
      const tb=$("logTable").querySelector('tbody');
      const tr=document.createElement('tr');
      const pre=computePreAcc();
      const gwhRange = `${fmt(pred.min)} ~ ${fmt(pred.max)}`;
      tr.innerHTML=`<td>${state.round}</td><td>${MONTHS[state.monthNow-1]}</td><td>${pre.score}%</td><td>${gwhRange}</td>`;
      tb.appendChild(tr);
    }
    function buildCSV(rows){ return rows.map(r=>r.join(',')).join('\n'); }
    function exportCSV(){
      const rows=[["round","month","pre_accuracy","predicted_gwh_min","predicted_gwh_max"]];
      const tb=$("logTable").querySelector('tbody');
      for(const tr of tb.querySelectorAll('tr')){
        const tds=[...tr.children].map(td=>td.textContent);
        const g = tds[3].split('~').map(s=>s.trim());
        rows.push([tds[0],tds[1],tds[2], g[0], g[1]]);
      }
      const csv = buildCSV(rows);
      const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='idpp_forecaster_log.csv'; a.click();
    }

    // ================== Modal & Start/Reset ==================
    function populateStartMonth(){ const sel=$("startMonth"); sel.innerHTML=''; for(let i=1;i<=12;i++){ const o=document.createElement('option'); o.value=i; o.textContent=MONTHS[i-1]; sel.appendChild(o);} }
    function openModal(){ $("modal").style.display='flex'; }
    function closeModal(){ $("modal").style.display='none'; }

    function openConfirmReset(){ $("confirmReset").style.display='flex'; }
    function closeConfirmReset(){ $("confirmReset").style.display='none'; }

    function startGame(){
      state.started=true; state.round=1; state.monthNow = +$("startMonth").value; state.scenario='A';
      $("roundNow").textContent = state.round;
      $("monthNow").textContent = MONTHS[state.monthNow-1];
      
      $("btnPredict").disabled=false; $("btnNext").disabled=false;
      // seed 2011 sample data (not card-based)
      seed2011();
      renderAcc(); buildYearTabs(); updateChart(2011);
    }

    function resetState(){ state.started=false; state.round=0; state.monthNow=1; state.scenario=null; state.demandCards=[]; state.tempCards=[]; state.appliedCodes=[]; $("predRange").value='—'; $("roundNow").textContent='—'; $("monthNow").textContent='—';  renderAppliedList(); renderAcc(); const tb=$("logTable").querySelector('tbody'); tb.innerHTML=''; $("yearTabs").innerHTML=''; $("yearSummary").textContent=''; $("yearTable").querySelector('tbody').innerHTML=''; if(chart){ chart.destroy(); chart=null; }  }

    function init(){
      state.cardDB = CARD_DB; injectGA6();
      

      $("btnNewGame").addEventListener('click', ()=>{ if(state.started){ openConfirmReset(); } else { populateStartMonth(); openModal(); } });
      $("btnResetNo").addEventListener('click', closeConfirmReset);
      $("btnResetYes").addEventListener('click', ()=>{ closeConfirmReset(); resetState(); populateStartMonth(); openModal(); });

      $("btnCancelScenario").addEventListener('click', closeModal);
      $("btnConfirmScenario").addEventListener('click', ()=>{ closeModal(); startGame(); });

      $("btnAddCode").addEventListener('click', applyCode);
      $("codeInput").addEventListener('keydown', (e)=>{ if(e.key==='Enter') applyCode(); });

      $("btnPredict").addEventListener('click', ()=>{ if(!state.started) return; const pred=predictCurrent(); $("predRange").value=`${fmt(pred.min)} ~ ${fmt(pred.max)}`; appendLog(pred); });
      $("btnNext").addEventListener('click', ()=>{ if(!state.started) return; if(state.round>=state.maxRounds){ alert('4라운드 종료. 새로운 게임을 시작하세요.'); return;} state.round++; state.monthNow = ((state.monthNow)%12)+1; $("roundNow").textContent=state.round; $("monthNow").textContent=MONTHS[state.monthNow-1]; clearHighlights(); renderAcc(); showRoundToast(); });

      $("btnExport").addEventListener('click', exportCSV);

      renderAppliedList(); renderAcc(); populateStartMonth(); runSelfTests();
    }
    document.addEventListener('DOMContentLoaded', init);
    document.addEventListener('click', (e)=>{ if(e.target && e.target.id==='btnCodeErrorClose'){ closeCodeError(); } });

    // ================== Lightweight Self Tests ==================
    function runSelfTests(){
      try{
        console.groupCollapsed('[SelfTest] Forecaster GWh');
        console.assert(monthDiff(1,12)===1, 'monthDiff wrap-around');
        console.assert(wMonth(5,5)===1.0 && wMonth(5,6)>wMonth(5,8), 'wMonth weights');
        console.assert(typeof buildYearTabs==='function', 'buildYearTabs defined');
        const pre0 = computePreAcc();
        console.assert(pre0.score===0 && pre0.label==='—', 'pre-accuracy when not started');
        console.assert(predictCurrent()===null, 'predictCurrent should be null before start');
        buildYearTabs(); const tabs = $("yearTabs"); console.assert(tabs.children.length===15, 'yearTabs should have 15 buttons');

        // GA6 DB sanity
        console.assert(CARD_DB['B2Q'] && CARD_DB['B2Q'].items && CARD_DB['B2Q'].items[0].hasOwnProperty('temp'), 'GA6 item carries temp');

        // Seed simulation
        const snap = JSON.parse(JSON.stringify({ started: state.started, scenario: state.scenario, round: state.round, monthNow: state.monthNow, demandCards: state.demandCards, tempCards: state.tempCards, appliedCodes: state.appliedCodes }));
        state.started=true; state.round=1; state.monthNow=1; state.scenario='A'; state.demandCards=[]; state.tempCards=[]; seed2011();
        const seeded2011 = state.demandCards.filter(d=>d.y===2011).length===12;
        console.assert(seeded2011, '2011 seeded with 12 demand months');
        const pre1 = computePreAcc();
        console.assert(pre1.score>=20 && pre1.score<=35, 'initial accuracy realistic (20-35%)');
        const model = buildRegressionModel(); const u1 = computeUncertainty(model);
        state.round=4; const u4 = computeUncertainty(model);
        console.assert(u4<u1 && u4<=0.9, 'uncertainty narrows and <=0.9 at R4');

        // Extra sanity: prediction object shape
        const p = predictCurrent(); console.assert(p && typeof p.min==='number' && typeof p.max==='number', 'predictCurrent returns range');

        state.started=snap.started; state.scenario=snap.scenario; state.round=snap.round; state.monthNow=snap.monthNow; state.demandCards=snap.demandCards; state.tempCards=snap.tempCards; state.appliedCodes=snap.appliedCodes;
        console.groupEnd();
      } catch(e) { console.warn('SelfTest failed', e); }
    }
  </script>
</body>
</html>
